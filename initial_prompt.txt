I have a PostgreSQL database for a subway system database with the following schema:

1. stations: Contains details about subway stations.
    - station_complex_id (TEXT): A unique identifier for each station, primary key.
    - station_complex (TEXT): The name of the station complex.
    - borough (TEXT): The city borough where the station is located.
    - latitude (NUMERIC(17,15)): Latitude coordinate of the station.
    - longitude (NUMERIC(17,15)): Longitude coordinate of the station.

2. routes: Contains unique subway routes.
    - route_name (TEXT): The name of the subway route/line, primary key.

3. station_routes: Represents the many-to-many relationship between stations and routes, linking which routes pass through each station.
    - station_complex_id (TEXT): References stations.station_complex_id.
    - route_name (TEXT): References routes.route_name.
    - This table has a composite primary key (station_complex_id, route_name).

4. ridership: Contains data on the number of riders at different times.
    - entry_id (INT PRIMARY KEY GENERATED ALWAYS AS IDENTITY): Unique identifier for each entry, primary key.
    - transit_timestamp (TIMESTAMP WITHOUT TIME ZONE): The date and time of the ridership count.
    - station_complex_id (TEXT): Links to the stations table.
    - metrocard_fair_fare, metrocard_full_fare, metrocard_other, metrocard_seniors_disability, metrocard_students, metrocard_unlimited_30_day, metrocard_unlimited_7_day, omny_full_fare, omny_other, omny_seniors_disability, total_metrocard_ridership, total_omny_ridership, total_ridership (INT): Various columns representing different fare types and counts.

Given this schema, convert the following natural language queries to valid PostgreSQL queries and extract station names and routes in a list as tuples of (station, route):
Note:  Note that users may call subway routes, "routes", "lines", or "subway lines" interchangeably.
Note: Some station_complexes have the same name. Users are suggested to provide a train route/line that services this station_complex in order to specify their exact station_complex.
    - They may do this in their query, or by including the route/line after the station_complex such as "111st (7)" or "111st - 7"  for the 7 train 111st station_complex.

Example 1:
Natural Language: "What was the station in brooklyn with the most ridership on march 3rd 2024 between 4pm and 8pm?"
Expected SQL Query: {"sql": "SELECT s.station_complex_id, s.station_complex, SUM(r.total_ridership) AS total_ridership
FROM ridership r
JOIN stations s ON r.station_complex_id = s.station_complex_id
WHERE s.borough = 'Brooklyn' AND r.transit_timestamp >= '2024-03-03 16:00:00' AND r.transit_timestamp < '2024-03-03 20:00:00'
GROUP BY s.station_complex_id, s.station_complex
ORDER BY total_ridership DESC
LIMIT 1;", "stations":null}

Example 2:
Natural Language: "What are the train lines that stop at 14 St-Union Sq"
Expected SQL Query: {"sql":"SELECT sr.route_name
FROM station_routes sr
JOIN stations s ON sr.station_complex_id = s.station_complex_id
WHERE s.station_complex ILIKE '%14 St-Union Sq%';", "stations":[("14 St-Union Sq", "")]}

Example 3:
Natural Language: "how many people used woodhaven blvd (J) on per day on average during 2023?"
Expected SQL Query: {"sql":"WITH ridership_6 AS (
    SELECT s.station_complex_id, s.station_complex, sr.route_name, SUM(r.total_ridership) AS total_ridership
    FROM ridership r
    JOIN stations s ON r.station_complex_id = s.station_complex_id
    JOIN station_routes sr ON s.station_complex_id = sr.station_complex_id
    WHERE s.station_complex = '86 St' AND sr.route_name = '6' AND r.transit_timestamp >= '2024-01-01' AND r.transit_timestamp < '2024-01-31'
    GROUP BY s.station_complex_id, s.station_complex, sr.route_name),
ridership_q AS (
    SELECT s.station_complex_id, s.station_complex, sr.route_name, SUM(r.total_ridership) AS total_ridership
    FROM ridership r
    JOIN stations s ON r.station_complex_id = s.station_complex_id
    JOIN station_routes sr ON s.station_complex_id = sr.station_complex_id
    WHERE s.station_complex = '86 St' AND sr.route_name = 'Q' AND r.transit_timestamp >= '2024-01-01' AND r.transit_timestamp < '2024-01-31'
    GROUP BY s.station_complex_id, s.station_complex, sr.route_name)
SELECT 
    CASE 
        WHEN COALESCE(r6.total_ridership, 0) > COALESCE(r_q.total_ridership, 0) THEN '86 St on the 6 line'
        WHEN COALESCE(r6.total_ridership, 0) < COALESCE(r_q.total_ridership, 0) THEN '86 St on the Q line'
        ELSE 'Both stations have equal ridership'
    END AS station_with_more_ridership,
    COALESCE(r6.total_ridership, 0) AS ridership_6,
    COALESCE(r_q.total_ridership, 0) AS ridership_q
FROM ridership_6 r6
FULL OUTER JOIN ridership_q r_q ON r6.station_complex = r_q.station_complex AND r6.route_name = r_q.route_name;", "stations":[("86 St, "6"), ("86 St", "Q")]}

Your task is to both translate natural language queries given by the user into valid PostgresQL queries based on the provided schema and examples given and also extract the names of any train stations in the natural language query. Return this output as JSON with the format '{"sql":{sql_query}, "stations": {[(station_1, route_1), ..., (station_n, route_n)]}}'. If no train station are mentioned, then return null for the stations entry. If no corresponding route for the station is mentioned, return a blank string for the route entry in the tuple. Return ONLY the SQL query for the sql_query entry.